{"ast":null,"code":"import { getAccessToken, getRefreshToken, isTokenExpired, refreshAccessToken, removeTokens } from './auth';\nimport API_BASE_URL from '../config/api';\n\n// Helper function to add JWT authentication to fetch requests\nexport const fetchWithAuth = async (url, options = {}) => {\n  try {\n    console.log(`Fetching with auth: ${url}`);\n\n    // Always include credentials for session-based auth as fallback\n    // This ensures requests work during the transition period\n    const baseOptions = {\n      ...options,\n      credentials: 'include',\n      headers: {\n        ...options.headers,\n        'Content-Type': 'application/json'\n      }\n    };\n\n    // Get the access token\n    let accessToken = getAccessToken();\n\n    // If no token, use session-based auth\n    if (!accessToken) {\n      console.log('No access token available, using session auth');\n      return fetch(url, baseOptions);\n    }\n\n    // If token exists but is expired, try to refresh it\n    if (isTokenExpired(accessToken)) {\n      console.log('Access token expired, attempting to refresh');\n      const refreshToken = getRefreshToken();\n      if (refreshToken) {\n        try {\n          accessToken = await refreshAccessToken(refreshToken, API_BASE_URL);\n          if (!accessToken) {\n            console.error('Failed to refresh token, clearing auth data');\n            removeTokens();\n            return fetch(url, baseOptions);\n          }\n        } catch (refreshError) {\n          console.error('Error refreshing token:', refreshError);\n          removeTokens();\n          return fetch(url, baseOptions);\n        }\n      } else {\n        console.error('No refresh token available, clearing auth data');\n        removeTokens();\n        return fetch(url, baseOptions);\n      }\n    }\n\n    // Add authorization header with the token\n    const authOptions = {\n      ...baseOptions,\n      headers: {\n        ...baseOptions.headers,\n        'Authorization': `Bearer ${accessToken}`\n      }\n    };\n\n    // Make the request with the authorization header\n    const response = await fetch(url, authOptions);\n\n    // Handle 401 Unauthorized errors\n    if (response.status === 401) {\n      console.log('Received 401 response, attempting token refresh');\n      // Try to refresh the token\n      const refreshToken = getRefreshToken();\n      if (refreshToken) {\n        try {\n          const newAccessToken = await refreshAccessToken(refreshToken, API_BASE_URL);\n          if (newAccessToken) {\n            console.log('Token refreshed successfully, retrying request');\n            // Retry the request with the new token\n            const newAuthOptions = {\n              ...baseOptions,\n              headers: {\n                ...baseOptions.headers,\n                'Authorization': `Bearer ${newAccessToken}`\n              }\n            };\n            return fetch(url, newAuthOptions);\n          }\n        } catch (refreshError) {\n          console.error('Error refreshing token:', refreshError);\n        }\n      }\n\n      // If we can't refresh, clear tokens and use session auth\n      console.error('Authentication failed after refresh attempt, clearing tokens');\n      removeTokens();\n\n      // Try session-based auth as fallback\n      return fetch(url, baseOptions);\n    }\n    return response;\n  } catch (error) {\n    console.error('Error in fetchWithAuth:', error);\n    // In case of any error, try with session auth as last resort\n    return fetch(url, {\n      ...options,\n      credentials: 'include',\n      headers: {\n        ...options.headers,\n        'Content-Type': 'application/json'\n      }\n    });\n  }\n};","map":{"version":3,"names":["getAccessToken","getRefreshToken","isTokenExpired","refreshAccessToken","removeTokens","API_BASE_URL","fetchWithAuth","url","options","console","log","baseOptions","credentials","headers","accessToken","fetch","refreshToken","error","refreshError","authOptions","response","status","newAccessToken","newAuthOptions"],"sources":["C:/Users/Radiance_Tech/Desktop/calendar-app/client/src/utils/api.js"],"sourcesContent":["import { getAccessToken, getRefreshToken, isTokenExpired, refreshAccessToken, removeTokens } from './auth';\nimport API_BASE_URL from '../config/api';\n\n// Helper function to add JWT authentication to fetch requests\nexport const fetchWithAuth = async (url, options = {}) => {\n  try {\n    console.log(`Fetching with auth: ${url}`);\n\n    // Always include credentials for session-based auth as fallback\n    // This ensures requests work during the transition period\n    const baseOptions = {\n      ...options,\n      credentials: 'include',\n      headers: {\n        ...options.headers,\n        'Content-Type': 'application/json',\n      }\n    };\n\n    // Get the access token\n    let accessToken = getAccessToken();\n\n    // If no token, use session-based auth\n    if (!accessToken) {\n      console.log('No access token available, using session auth');\n      return fetch(url, baseOptions);\n    }\n\n    // If token exists but is expired, try to refresh it\n    if (isTokenExpired(accessToken)) {\n      console.log('Access token expired, attempting to refresh');\n      const refreshToken = getRefreshToken();\n      if (refreshToken) {\n        try {\n          accessToken = await refreshAccessToken(refreshToken, API_BASE_URL);\n          if (!accessToken) {\n            console.error('Failed to refresh token, clearing auth data');\n            removeTokens();\n            return fetch(url, baseOptions);\n          }\n        } catch (refreshError) {\n          console.error('Error refreshing token:', refreshError);\n          removeTokens();\n          return fetch(url, baseOptions);\n        }\n      } else {\n        console.error('No refresh token available, clearing auth data');\n        removeTokens();\n        return fetch(url, baseOptions);\n      }\n    }\n\n    // Add authorization header with the token\n    const authOptions = {\n      ...baseOptions,\n      headers: {\n        ...baseOptions.headers,\n        'Authorization': `Bearer ${accessToken}`\n      }\n    };\n\n    // Make the request with the authorization header\n    const response = await fetch(url, authOptions);\n\n    // Handle 401 Unauthorized errors\n    if (response.status === 401) {\n      console.log('Received 401 response, attempting token refresh');\n      // Try to refresh the token\n      const refreshToken = getRefreshToken();\n      if (refreshToken) {\n        try {\n          const newAccessToken = await refreshAccessToken(refreshToken, API_BASE_URL);\n          if (newAccessToken) {\n            console.log('Token refreshed successfully, retrying request');\n            // Retry the request with the new token\n            const newAuthOptions = {\n              ...baseOptions,\n              headers: {\n                ...baseOptions.headers,\n                'Authorization': `Bearer ${newAccessToken}`\n              }\n            };\n            return fetch(url, newAuthOptions);\n          }\n        } catch (refreshError) {\n          console.error('Error refreshing token:', refreshError);\n        }\n      }\n\n      // If we can't refresh, clear tokens and use session auth\n      console.error('Authentication failed after refresh attempt, clearing tokens');\n      removeTokens();\n\n      // Try session-based auth as fallback\n      return fetch(url, baseOptions);\n    }\n\n    return response;\n  } catch (error) {\n    console.error('Error in fetchWithAuth:', error);\n    // In case of any error, try with session auth as last resort\n    return fetch(url, {\n      ...options,\n      credentials: 'include',\n      headers: {\n        ...options.headers,\n        'Content-Type': 'application/json',\n      }\n    });\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}