{"ast":null,"code":"import { getAccessToken, getRefreshToken, isTokenExpired, refreshAccessToken, removeTokens } from './auth';\nimport API_BASE_URL from '../config/api';\n\n// Helper function to add JWT authentication to fetch requests\nexport const fetchWithAuth = async (url, options = {}) => {\n  try {\n    console.log(`Fetching with auth: ${url}`);\n\n    // Get the access token\n    let accessToken = getAccessToken();\n\n    // For calendar availability endpoints, always include session credentials\n    // This ensures Google Calendar API calls work during the JWT transition\n    const isCalendarRequest = url.includes('/api/availability/');\n\n    // If it's a calendar request or we have no token, use session auth\n    if (isCalendarRequest || !accessToken) {\n      console.log(isCalendarRequest ? 'Calendar request: using session auth' : 'No access token available: using session auth');\n      // Include credentials for session-based auth\n      return fetch(url, {\n        ...options,\n        credentials: 'include',\n        headers: {\n          ...options.headers,\n          'Content-Type': 'application/json'\n        }\n      });\n    }\n\n    // If token exists but is expired, try to refresh it\n    if (isTokenExpired(accessToken)) {\n      console.log('Access token expired, attempting to refresh');\n      const refreshToken = getRefreshToken();\n      if (refreshToken) {\n        accessToken = await refreshAccessToken(refreshToken, API_BASE_URL);\n        if (!accessToken) {\n          console.error('Failed to refresh token, clearing auth data');\n          removeTokens();\n          // Fall back to session-based auth\n          return fetch(url, {\n            ...options,\n            credentials: 'include',\n            headers: {\n              ...options.headers,\n              'Content-Type': 'application/json'\n            }\n          });\n        }\n      } else {\n        console.error('No refresh token available, clearing auth data');\n        removeTokens();\n        // Fall back to session-based auth\n        return fetch(url, {\n          ...options,\n          credentials: 'include',\n          headers: {\n            ...options.headers,\n            'Content-Type': 'application/json'\n          }\n        });\n      }\n    }\n\n    // Add authorization header with the token\n    const headers = {\n      ...options.headers,\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${accessToken}`\n    };\n\n    // Make the request with the authorization header\n    const response = await fetch(url, {\n      ...options,\n      headers\n    });\n\n    // Handle 401 Unauthorized errors\n    if (response.status === 401) {\n      console.log('Received 401 response, attempting token refresh');\n      // Try to refresh the token\n      const refreshToken = getRefreshToken();\n      if (refreshToken) {\n        const newAccessToken = await refreshAccessToken(refreshToken, API_BASE_URL);\n        if (newAccessToken) {\n          console.log('Token refreshed successfully, retrying request');\n          // Retry the request with the new token\n          headers['Authorization'] = `Bearer ${newAccessToken}`;\n          return fetch(url, {\n            ...options,\n            headers\n          });\n        }\n      }\n\n      // If we can't refresh, clear tokens and try session auth\n      console.error('Authentication failed after refresh attempt, clearing tokens');\n      removeTokens();\n\n      // Fall back to session-based auth\n      return fetch(url, {\n        ...options,\n        credentials: 'include',\n        headers: {\n          ...options.headers,\n          'Content-Type': 'application/json'\n        }\n      });\n    }\n    return response;\n  } catch (error) {\n    console.error('Error in fetchWithAuth:', error);\n    // In case of any error, try with session auth as last resort\n    return fetch(url, {\n      ...options,\n      credentials: 'include',\n      headers: {\n        ...options.headers,\n        'Content-Type': 'application/json'\n      }\n    });\n  }\n};","map":{"version":3,"names":["getAccessToken","getRefreshToken","isTokenExpired","refreshAccessToken","removeTokens","API_BASE_URL","fetchWithAuth","url","options","console","log","accessToken","isCalendarRequest","includes","fetch","credentials","headers","refreshToken","error","response","status","newAccessToken"],"sources":["C:/Users/Radiance_Tech/Desktop/calendar-app/client/src/utils/api.js"],"sourcesContent":["import { getAccessToken, getRefreshToken, isTokenExpired, refreshAccessToken, removeTokens } from './auth';\nimport API_BASE_URL from '../config/api';\n\n// Helper function to add JWT authentication to fetch requests\nexport const fetchWithAuth = async (url, options = {}) => {\n  try {\n    console.log(`Fetching with auth: ${url}`);\n\n    // Get the access token\n    let accessToken = getAccessToken();\n\n    // For calendar availability endpoints, always include session credentials\n    // This ensures Google Calendar API calls work during the JWT transition\n    const isCalendarRequest = url.includes('/api/availability/');\n\n    // If it's a calendar request or we have no token, use session auth\n    if (isCalendarRequest || !accessToken) {\n      console.log(isCalendarRequest ? 'Calendar request: using session auth' : 'No access token available: using session auth');\n      // Include credentials for session-based auth\n      return fetch(url, {\n        ...options,\n        credentials: 'include',\n        headers: {\n          ...options.headers,\n          'Content-Type': 'application/json',\n        }\n      });\n    }\n\n    // If token exists but is expired, try to refresh it\n    if (isTokenExpired(accessToken)) {\n      console.log('Access token expired, attempting to refresh');\n      const refreshToken = getRefreshToken();\n      if (refreshToken) {\n        accessToken = await refreshAccessToken(refreshToken, API_BASE_URL);\n        if (!accessToken) {\n          console.error('Failed to refresh token, clearing auth data');\n          removeTokens();\n          // Fall back to session-based auth\n          return fetch(url, {\n            ...options,\n            credentials: 'include',\n            headers: {\n              ...options.headers,\n              'Content-Type': 'application/json',\n            }\n          });\n        }\n      } else {\n        console.error('No refresh token available, clearing auth data');\n        removeTokens();\n        // Fall back to session-based auth\n        return fetch(url, {\n          ...options,\n          credentials: 'include',\n          headers: {\n            ...options.headers,\n            'Content-Type': 'application/json',\n          }\n        });\n      }\n    }\n\n    // Add authorization header with the token\n    const headers = {\n      ...options.headers,\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${accessToken}`\n    };\n\n    // Make the request with the authorization header\n    const response = await fetch(url, {\n      ...options,\n      headers,\n    });\n\n    // Handle 401 Unauthorized errors\n    if (response.status === 401) {\n      console.log('Received 401 response, attempting token refresh');\n      // Try to refresh the token\n      const refreshToken = getRefreshToken();\n      if (refreshToken) {\n        const newAccessToken = await refreshAccessToken(refreshToken, API_BASE_URL);\n        if (newAccessToken) {\n          console.log('Token refreshed successfully, retrying request');\n          // Retry the request with the new token\n          headers['Authorization'] = `Bearer ${newAccessToken}`;\n          return fetch(url, {\n            ...options,\n            headers,\n          });\n        }\n      }\n\n      // If we can't refresh, clear tokens and try session auth\n      console.error('Authentication failed after refresh attempt, clearing tokens');\n      removeTokens();\n\n      // Fall back to session-based auth\n      return fetch(url, {\n        ...options,\n        credentials: 'include',\n        headers: {\n          ...options.headers,\n          'Content-Type': 'application/json',\n        }\n      });\n    }\n\n    return response;\n  } catch (error) {\n    console.error('Error in fetchWithAuth:', error);\n    // In case of any error, try with session auth as last resort\n    return fetch(url, {\n      ...options,\n      credentials: 'include',\n      headers: {\n        ...options.headers,\n        'Content-Type': 'application/json',\n      }\n    });\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}